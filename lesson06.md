# Урок 6. Import, tuple, set, dict.

## Імпорт бібліотек

Є три варіанти імпорту бібліотек: імпорт повністю всієї бібліотеки, імпорт переліку функцій з неї або імпорт функції з псевдонімом:

```python
import sys #
from sys import argv #
from sys import argv as cli_param #
```

## Tuple (кортеж...)

Кортежі (англ. tuple) використовується уявлення незмінної послідовності різнорідних об'єктів. Вони зазвичай записуються в круглих дужках, але якщо неоднозначності немає, то дужки можна опустити.


```python
# New tuple made of different types
>>> t = (2, 2.05, "Hello")
>>> t
(2, 2.05, 'Hello')
# Assigning three different variables using tuple, multiple assignment
>>> (a, b, c) = t
>>> print(a, b, c)
2 2.05 Hello
>>> z, y, x = t
>>> print(z, y, x)
2 2.05 Hello
# Creating one element tuple
>>> x = 12,
>>> x
(12,)
# Creating tuple w/o brackets
>>> tup = 1, 2, 'qwerty'
>>> tup
(1, 2, 'qwerty')
```

До кортежів застосовуються багато функцій з тих, що застосовуються до списків: отримання довжини кортежу, конкатенація (склеювання) кортежу, зрізи, методи index і count:

```python
>>> t = 1, 2, 3
>>> t = t + (4, 5)
>>> t
(1, 2, 3, 4, 5)
>>> t[:-1]
(1, 2, 3, 4)
>>> t[2:-1]
(3, 4)
>>> len(t)
5
>>> t.index(2)
1
>>> t.count(3)
1
```

Як видно з прикладу, кортеж може бути використаний і в лівій частині оператора присвоєння. Значення кортежу в лівій частині оператора привласнення зв'язуються з аналогічними елементами правої частини. Цей факт дає нам такі чудові можливості як масова ініціалізація змінних і повернення безлічі значень з функції одночасно.

Найчастіше кортежі використовують для того, щоб одержати дані з функції, зберігати дані тощо. Особливості роботи з ними:

- робота з ними швидше (порівняно зі списками);
- займають у пам'яті менше місця;
- можуть виступати як ключі для словника;
- не мають окремих методів;
- використовуються для масової ініціалізації змінних та повернення відразу кількох значень з функції.


## Set (Множина)

Сети - від математичної 'множини' - невідсортована колекція унікальних елементів. У цьому визначенні згадані дві основні особливості сетів – унікальність та відсутність сортування.

**Унікальність** - сет містить лише унікальні елементи, якщо додавати до нього дублікати - вони не додаються, якщо перевести аркуш у сет - елементи, що повторюються, будуть видалені.

**Відсутність сортування** - елементи в сеті знаходяться в певному хаотичному порядку.

Множини підтримують перебір всіх елементів (ітерацію), додавання та видалення елементів, але через відсутність сортування не підтримують індексацію та зрізи. Створення множин:


```python
>>> a = {1, 2, 3, 4, 5, 4, 3, 4, 5, 6, 5, 4, 3}
>>> a
{1, 2, 3, 4, 5, 6}

>>> b = {1, 2, 3, 'a', 'c', 0.34}
>>> b
{0.34, 1, 2, 3, 'a', 'c'}
```

Множини підтримують деякі операції:

```python
>>> set1 = {1, 2, 3, 4, 5, 6}
>>> set2 = {5, 6, 7, 8, 9}
>>> set1 - set2 # Sets difference
{1, 2, 3, 4}

>>> set1 | set2 # Sets union
{1, 2, 3, 4, 5, 6, 7, 8, 9}

>>> set1 & set2 # Sets cross
{5, 6}
```

Додати елемент до множини можна за допомогою функції add, а видалити з множини елемент - за допомогою функції remove. Як параметр виступає сам елемент, оскільки індексів у множині немає.

```python
>>> set1.add(7)
>>> set1
{1, 2, 3, 4, 5, 6, 7}
>>> set1.remove(1)
>>> set1
{2, 3, 4, 5, 6, 7, 8}
```

Сети можна використовувати для фільтрації дублів у колекціях. Для цього колекцію потрібно конвертувати в сет, а потім назад:

```python
>>> L = [1, 2, 3, 4, 3, 2, 5, 6, 7, 5, 3, 2]
>>> L
[1, 2, 3, 4, 3, 2, 5, 6, 7, 5, 3, 2]
>>> L = list(set(L))
>>> L
[1, 2, 3, 4, 5, 6, 7]
```


Сети можна використовувати для роботи з великими наборами даних: припустимо, у нас є бази даних програмістів та менеджерів:

```python
>>> programmers = {'ivanov','petrov','sidorov'}
>>> managers = {'ivanov','moxov','goroxov'}

>>> programmers & managers
{'ivanov'}

>>> programmers | managers
{'ivanov', 'petrov', 'sidorov', 'goroxov', 'moxov'}

>>> programmers - managers
{'petrov', 'sidorov'}
```
Але при роботі з Множинами слід пам'ятати, що вони є неіндексованим типом даних, а отже у разі їх використання у вас не вийде доступитись до якогось окремого їх елемента за індексом. Власне, окремі елементи множин можна отримати або перебравши їх послідовно, або перетворивши у список чи краще кортеж.


## 4. Dict (Словник)


Словник (хеш, асоціативний масив) – мінлива та невпорядкована структура даних, призначена для зберігання елементів виду ключ: значення.

Значенням елемента словника може бути будь-який тип даних, ключем елемента - будь-який незмінний (immutable) тип даних, тобто str, int, float, tuple та ін.

### Створення словника

Є кілька способів створити словник: пряме створення, створення за допомогою перетворення на тип (використовуючи функцію dict), використовуючи функцію fromkeys та через генератор словників :)

Розглянемо всі ці методи з прикладу:

```python
>>> d = {}
>>> d
{}
>>> d1 = {'a':1, 'b': 2}
>>> d1
{'a': 1, 'b': 2}


>>> d = dict(short='dict', long='dictionary')
>>> d
{'short': 'dict', 'long': 'dictionary'}
>>> d = dict([(1, 1), (2, 4)])
>>> d
{1: 1, 2: 4}


d = dict.fromkeys(['a', 'b', 1, (1, 2)])
>>> d
{'a': None, 1: None, 'b': None, (1, 2): None}

>>> d = dict.fromkeys(['a', 'b', 1, (1, 2)], 4)
>>> d
{'a': 4, 1: 4, 'b': 4, (1, 2): 4}


>>> d = {a: a ** 2 for a in range(7)}
>>> d
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36}
```


Функція dict має одну особливість, з її допомогою можна швидко створювати словники з ключами-рядками, опускаючи лапки. Це показано на прикладі нижче. На жаль, працює тільки з явними рядками, принцип формування яких такий самий, як і принцип найменування змінних:

```python
>>> dict(a=1, b=2, c=3, d=13)
{'a': 1, 'c': 3, 'b': 2, 'd': 13}
>>> dict(a=1, b=2, c=3, d=13, 1=2)
  File "<stdin>", line 1
SyntaxError: keyword can't be an expression
>>> dict(a=1, b=2, c=3, d=13, '1'=2)
  File "<stdin>", line 1
SyntaxError: keyword can't be an expression
```

### Операції зі словниками

Зі словниками доступні операції взяття елемента, видалення елемента, додавання елемента та його оновлення:

```python
>>> d = dict(a=1, b=2, c=3, d=13)
>>> d
{'a': 1, 'c': 3, 'b': 2, 'd': 13}
>>> d['a']
1
>>> d[1] = 15
>>> d
{'a': 1, 1: 15, 'c': 3, 'b': 2, 'd': 13}
>>> del d[1]
>>> d
{'a': 1, 'c': 3, 'b': 2, 'd': 13}
>>> d['a'] = 111
>>> d['a']
111
```
Взяття елемента зі словника по ключу краще здійснювати не через квадратні дужки, а за допомогою методу .get(). Якщо елемент відсутній, звичайне взяття по ключу видасть помилку, а метод .get() дозволяє цього уникнути:

```python
>>> d['a']
1
>>> d['e']
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 'e'
>>> d.get('e')
>>>
>>> d.get('e', 'No such element')
'No such element'
>>>
```

### Методи та функції для роботи зі словниками

```python

>>> d
{'a': 1, 'c': 3, 'b': 2, 'd': 13}
>>> d.update({'4': 4, '5': 5})
>>> d
{'a': 1, 'c': 3, 'b': 2, '5': 5, 'd': 13, '4': 4}


>>> len(d)
6

>>> d.keys()
['a', 'c', 'b', '5', 'd', '4']
>>> d.values()
[1, 3, 2, 5, 13, 4]
>>> d.items()
dict_items([('a', 1), ('c', 3), ('b', 2), ('d', 13), ('4', 4), ('5', 5)])
```

Словники можна чудово проходити у циклі:

```python
for key in d.keys():
    print(key, d[key])
for key, val in d.items():
    print(key, val)
```

І насамкінець - маленький кумедний приклад використання словника. Нагадую, що значенням може бути будь-що:

```python
 >>> calculator = {
    'plus': lambda x, y: x + y,
    'minus': lambda x, y: x - y,
    'mul': lambda x, y: x*y,
    'div': lambda x, y: x/y,
    'mod': lambda x, y: x%y
}
calculator['minus'](9,3)
6
```
Слід відмітити, що дещо подібний з цим метод можна використовувати для прискорення роботи програми, у випадку багатогілкового розгалудження. Даний метод може використовуватись також і у інших мовах програмування, у яких існує тип даних hash table, наприклад С++:
До прикладу - візьмемо код, з розгалуджннями, кожне з яких викликає окрему функцію:

```python
def do_one(x):
  print('one')
def do_two(x):
  print('two')
def do_three(x):
  print('tree')
def do_default(x):
  print(x)

x=2
if x==1:
  do_one(x)
elif x==2:
  do_two(x)
elif x==3:
  do_three(x)
else:
  do_default(x)
```
У цьому випадку таку і більшу кількість розгалуджень можна замінити словником, де у якості ключів вказані очікувані значення, а у якості значень - викликані функції:
```python
actions={1: do_one(x), 2: do_two(x), 3: do_three(x)}
```
Зверніть увагу, що у даному словнику відсутня гілка `else`, яка викликає функцію `do_default(x)`. Але у разі вказання такого значення як вказаного по замовчуванню (дефолтного) для методу .get() застосовуваного до цього словника, де першим аргументом йде оброблювана величина, наступний код буде призводити до того самого результату:

```python
action=actions.get(x, do_default)
action(x)
```


Цікаво, що при роботі з словниками їх можна сортувати. Але якщо ви їх будете просто сортувати, то відбудеться сортування словника саме за ключами. Якщо ж вам необхідно здійснити сортування словника за значеннями, то варто використати наступний код:

```python
students={'Mark': 11, 'Alexander': 36, 'Dietrich': 82, 'Gretchen': 29}
sudents=dict(sorted(students.items(), key=lambda x: x[1]))
print(students) #{'Mark': 11, 'Gretchen': 29, 'Alexander': 36, 'Dietrich': 82}
```

### Практичні завдання

1. Створити словник оцінок передбачуваних студентів (Ключ – ПІ студента, значення – список оцінок студентів). Знайти найуспішнішого і самого слабенького за середнім балом.
2. Створити структуру даних для студентів з імен та прізвищ, можна випадкових. Придумати структуру даних, щоб вказувати, у якій групі навчається студент (Групи Python, FrontEnd, FullStack, Java). Студент може навчатися у кількох групах. Потім вивести:

- студентів, які навчаються у двох та більше групах
- студентів, які не навчаються на фронтенді
- студентів, які вивчають Python або Java

3. Написати функцію переведення розмірів жіночої білизни з міжнародної у решту. Всередині функції потрібно просто звертатися до правильно складеного словника.

![](https://www.mirtrik.by/lp/seo-posts/image02.jpg)

### Домашки немає, практикуємося, готуємося до модульних завдань, далі уроки з git.




